Mobile App

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) => MaterialApp(
    title: 'Smart Parking Dashboard',
    theme: ThemeData(
      primarySwatch: Colors.indigo,
      visualDensity: VisualDensity.adaptivePlatformDensity,
      cardTheme: CardTheme(
        elevation: 4,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        ),
      ),
    ),
    home: const DashboardPage(),
  );
}

/* ---------- simple slot model ---------- */
class Slot {
  final int status; // 0 free | 1 full | 2 reserved
  final String id; // driver id when full
  final String bookedBy; // user id when reserved
  const Slot(this.status, this.id, this.bookedBy);
}

class DashboardPage extends StatefulWidget {
  const DashboardPage({super.key});
  @override
  State<DashboardPage> createState() => _DashboardPageState();
}

class _DashboardPageState extends State<DashboardPage> {
  final _otpController = TextEditingController();
  final _db = FirebaseDatabase.instance.ref();

  final _deviceIds = List.generate(6, (i) => 'test${i + 1}');
  String _selectedId = 'test1';

  String? _message;
  List<Slot>? _row1; // 6 slots w/ status+id
  List<Slot>? _row2; // 6 slots row‑2
  Map<String, double> _balances = {}; // id -> wallet balance

  /* ------------ Check if all spots are full ------------ */
  bool _isFullyOccupied() {
    if (_row1 == null || _row2 == null) return false;
    return _row1!.every((s) => s.status == 1) && _row2!.every((s) => s.status == 1);
  }

  /* ------------ Check if current user already booked a slot ------------ */
  bool _hasExistingBooking() {
    bool booked(List<Slot>? row) => row?.any((s) => s.status == 2 && s.bookedBy == _selectedId) ?? false;
    return booked(_row1) || booked(_row2);
  }

  /* ------------ OTP submit ------------ */
  Future<void> _submitOtp() async {
    if (_isFullyOccupied()) {
      setState(() => _message = 'Parking is full!');
      return;
    }

    try {
      final snap = await _db.child('otp').get();
      if (!snap.exists) throw 'OTP node missing';
      final map = Map<String, dynamic>.from(snap.value as Map);
      final ent = map['entry_otp'].toString();
      final ex = map['exit_otp'].toString();
      final entered = _otpController.text.trim();

      if (entered == ent || entered == ex) {
        await _db.child('commands/esp32').set({
          'action': entered == ent ? 'entry' : 'exit',
          'timestamp': ServerValue.timestamp,
          'id': _selectedId,
        });
        setState(() {
          _message = 'OTP Verified!';
          _otpController.clear();
        });
        _showSuccessSnackBar('OTP verified successfully!');
      } else {
        setState(() => _message = 'Invalid OTP!');
        _showErrorSnackBar('Invalid OTP!');
      }
    } catch (e) {
      setState(() => _message = 'Error: $e');
      _showErrorSnackBar('Error: $e');
    }
  }

  /* ------------ Add ₹10 to selected wallet ------------ */
  Future<void> _addTen() async {
    final path = 'users/$_selectedId/wallet/balance';
    try {
      await _db.child(path).runTransaction((value) {
        final current = double.tryParse(value?.toString() ?? '0') ?? 0.0;
        final updated = (current + 10).toStringAsFixed(2);
        return Transaction.success(updated);
      });
      // local optimistic update
      setState(() => _balances[_selectedId] = (_balances[_selectedId] ?? 0) + 10.0);
      _showSuccessSnackBar('Added ₹10 successfully!');
    } catch (e) {
      setState(() => _message = 'Error adding money: $e');
      _showErrorSnackBar('Error adding money: $e');
    }
  }

  /* ------------ Parse slot data from Firebase ------------ */
  List<Slot> _parseSlots(Map<String, dynamic> map, int slotCount) {
    return List.generate(slotCount, (i) {
      final slotKey = 'slot${i + 1}';
      final slot = map[slotKey];
      if (slot is Map) {
        return Slot(
          int.tryParse(slot['status'].toString()) ?? 0,
          (slot['id'] ?? '').toString(),
          (slot['booked'] ?? '').toString(),
        );
      }
      return Slot(int.tryParse(slot?.toString() ?? '0') ?? 0, '', '');
    });
  }

  /* ------------ Firebase listeners ------------ */
  void _watchRow1() {
    _db.child('row1').onValue.listen((event) {
      if (event.snapshot.value == null) return;
      final map = Map<String, dynamic>.from(event.snapshot.value as Map);
      setState(() => _row1 = _parseSlots(map, 6));
    });
  }

  void _watchRow2() {
    _db.child('row2').onValue.listen((event) {
      if (event.snapshot.value == null) return;
      final map = Map<String, dynamic>.from(event.snapshot.value as Map);
      setState(() => _row2 = _parseSlots(map, 6));
    });
  }

  void _watchBalances() {
    _db.child('users').onValue.listen((event) {
      if (event.snapshot.value == null) return;
      final map = Map<String, dynamic>.from(event.snapshot.value as Map);
      final tmp = <String, double>{};
      map.forEach((id, userData) {
        if (userData is Map && userData['wallet'] != null) {
          final wallet = Map<String, dynamic>.from(userData['wallet']);
          final bal = double.tryParse(wallet['balance'].toString()) ?? 0.0;
          tmp[id] = bal;
        }
      });
      setState(() => _balances = tmp);
    });
  }

  /* ------------ helpers ------------ */
  double _balanceForSelected() => _balances[_selectedId] ?? 0.0;

  void _showSuccessSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green.shade800,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        margin: const EdgeInsets.all(8),
      ),
    );
  }

  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red.shade800,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        margin: const EdgeInsets.all(8),
      ),
    );
  }

  Widget _buildBalancesList() {
    if (_balances.isEmpty) {
      return const Text('No wallet data');
    }
    final ids = _balances.keys.toList()..sort();
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: ids
              .map((id) => Padding(
            padding: const EdgeInsets.symmetric(vertical: 4),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  id,
                  style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                Text(
                  '₹${_balances[id]!.toStringAsFixed(2)}',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                    color: Colors.indigo.shade800,
                  ),
                ),
              ],
            ),
          ))
              .toList(),
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    _watchRow1();
    _watchRow2();
    _watchBalances();
  }

  @override
  void dispose() {
    _otpController.dispose();
    super.dispose();
  }

  /* ------------ Booking logic ------------ */
  Future<void> _bookSlot(String rowKey, int index) async {
    // --->>> *** ADDED PRE-CHECKS *** <<<---
    if (_hasExistingBooking()) {
      setState(() => _message = 'You already have a booking.');
      _showErrorSnackBar('You already have a booking.');
      return;
    }
    // Optional: Add a balance check if booking costs something initially
    // if (_balanceForSelected() < 5.0) { // Example: Minimum balance of 5 needed
    //    setState(() => _message = 'Insufficient balance for booking.');
    //    _showErrorSnackBar('Insufficient balance for booking.');
    //    return;
    //  }
    // --->>> *** END OF ADDED PRE-CHECKS *** <<<---


    final slotRef = _db.child('$rowKey/slot${index + 1}');
    try {
      final result = await slotRef.runTransaction((value) {
        // --->>> *** REFINED TRANSACTION LOGIC *** <<<---
        // Make sure value is a Map before accessing keys
        if (value is Map) {
          final currentStatus = int.tryParse(value['status']?.toString() ?? '-1') ?? -1;
          // Check if the slot is free (status 0)
          if (currentStatus == 0) {
            value['status'] = 2; // Set status to reserved
            value['booked'] = _selectedId; // Set bookedBy ID
            // --->>> *** ADDED TIMESTAMP FOR BOOKING TIME IN SLOT DATA *** <<<---
            value['bookedTimestamp'] = ServerValue.timestamp;
            return Transaction.success(value);
          } else {
            // Slot is not free (occupied or already reserved)
            return Transaction.abort(); // Abort the transaction
          }
        } else {
          // Handle cases where the slot data isn't a map (e.g., first time creation or data corruption)
          // If it's null, assume it's a fresh slot we can book
          if (value == null) {
            return Transaction.success({
              'status': 2, // reserved
              'booked': _selectedId,
              'bookedTimestamp': ServerValue.timestamp,
              'id': '' // Initialize occupied ID field as empty
            });
          } else {
            // If it exists but is not a map, abort to prevent overwriting potentially valid (but different format) data.
            _showErrorSnackBar('Slot data format error. Cannot book.'); // Inform user
            print('Error: Slot data at $rowKey/slot${index + 1} is not a Map: $value'); // Log for debugging
            return Transaction.abort();
          }
        }
        // --->>> *** END OF REFINED TRANSACTION LOGIC *** <<<---
      });

      // Check if the transaction was successful
      if (!result.committed) {
        // Transaction failed (e.g., slot was booked by someone else concurrently, or aborted above)
        setState(() => _message = 'Booking failed. Slot might be taken or unavailable.');
        _showErrorSnackBar('Booking failed. Slot might be taken or unavailable.');
        return; // Exit the function early if booking failed
      }

      // --->>> *** START OF ADDED COMMAND LOGIC *** <<<---
      // Log command for ESP32 only *after* successful booking transaction
      final String slotIdentifier = '$rowKey/slot${index + 1}'; // e.g., "row1/slot3"
      await _db.child('commands/esp32').set({
        'action': 'booking',                // Indicate booking action
        'timestamp': ServerValue.timestamp, // Server time of the command
        'id': _selectedId,                  // User who booked
        'slot': slotIdentifier,             // Specific slot booked
      });
      // --->>> *** END OF ADDED COMMAND LOGIC *** <<<---

      // If transaction and command log succeeded:
      setState(() => _message = 'Slot ${index + 1} in $rowKey booked!');
      _showSuccessSnackBar('Slot booked successfully!');

    } catch (e) {
      // Catch potential errors during the transaction or command logging
      setState(() => _message = 'Booking error: $e');
      _showErrorSnackBar('Booking error: $e');
      print('Booking transaction/command error: $e'); // Log detailed error
    }
  }

  /* ------------ Cancel reservation logic ------------ */
  Future<void> _cancelReservation(String rowKey, int index) async {
    final slotRef = _db.child('$rowKey/slot${index + 1}');
    try {
      final result = await slotRef.runTransaction((value) {
        if (value is Map &&
            int.tryParse(value['status'].toString()) == 2 &&
            value['booked'].toString() == _selectedId) {
          // reserved → free
          value['status'] = 0;
          value['booked'] = '';
          return Transaction.success(value);
        }
        return Transaction.abort();
      });

      if (!result.committed) {
        setState(() => _message = 'Cannot cancel this reservation.');
        _showErrorSnackBar('Cannot cancel this reservation.');
        return;
      }

      // Log command for ESP32
      await _db.child('commands/esp32').set({
        'action': 'cancelled',
        'timestamp': ServerValue.timestamp,
        'id': _selectedId,
      });
      setState(() => _message = 'Reservation cancelled!');
      _showSuccessSnackBar('Reservation cancelled successfully!');
    } catch (e) {
      setState(() => _message = 'Cancellation failed: $e');
      _showErrorSnackBar('Cancellation failed: $e');
    }
  }

  void _confirmBooking(String rowKey, int index) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Confirm Reservation'),
        content: const Text('Book this parking slot?'),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(ctx).pop();
              _bookSlot(rowKey, index);
            },
            child: const Text('Book'),
          ),
        ],
      ),
    );
  }

  void _confirmCancellation(String rowKey, int index) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Cancel Reservation'),
        content: const Text('Cancel your reservation for this parking slot?'),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Keep Reservation'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () {
              Navigator.of(ctx).pop();
              _cancelReservation(rowKey, index);
            },
            child: const Text('Cancel Reservation'),
          ),
        ],
      ),
    );
  }

  /* ------------ UI ------------ */
  /* ------------ UI ------------ */
  Widget _buildRow(List<Slot> row, String rowKey, String label) => Card(
    margin: const EdgeInsets.symmetric(vertical: 6), // Slightly reduced vertical margin
    child: Padding(
      // Reduced padding inside the card
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Padding(
            // Reduced padding below the label
            padding: const EdgeInsets.only(bottom: 8.0),
            child: Text(label,
                style: const TextStyle(fontSize: 17, fontWeight: FontWeight.w600)), // Slightly smaller font
          ),
          // Use Wrap instead of Row for responsiveness
          Wrap(
            alignment: WrapAlignment.center, // Center items horizontally
            spacing: 6.0, // Horizontal space between slots
            runSpacing: 6.0, // Vertical space between rows of slots if they wrap
            children: List.generate(row.length, (index) {
              final slot = row[index];
              Color color;
              IconData? iconData;

              switch (slot.status) {
                case 0:
                  color = Colors.green.shade400; // Slightly lighter green
                  iconData = Icons.check_circle_outline;
                  break;
                case 1:
                  color = Colors.red.shade400; // Slightly lighter red
                  iconData = Icons.directions_car;
                  break;
                case 2:
                  color = Colors.purple.shade400; // Slightly lighter purple
                  iconData = Icons.bookmark;
                  break;
                default:
                  color = Colors.grey;
                  iconData = null;
              }

              // This Column represents a single parking slot visually
              final slotWidget = Column(
                mainAxisSize: MainAxisSize.min, // Important for Wrap
                children: [
                  Container(
                    // Reduced size and margin for the main square
                    margin: const EdgeInsets.all(3), // Smaller margin
                    width: 38, // Smaller width
                    height: 38, // Smaller height
                    decoration: BoxDecoration(
                      color: color.withOpacity(0.9), // Slightly more opaque
                      borderRadius: BorderRadius.circular(8), // Slightly smaller radius
                      boxShadow: [
                        BoxShadow(
                          color: color.withOpacity(0.25), // Slightly less intense shadow
                          blurRadius: 3,
                          offset: const Offset(0, 1.5),
                        ),
                      ],
                    ),
                    // Reduced icon size
                    child: iconData != null ? Icon(iconData, color: Colors.white, size: 20) : null,
                  ),
                  // Only show ID/BookedBy text if the slot is not free
                  if (slot.status != 0)
                    Container(
                      // Reduced padding
                      padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1),
                      decoration: BoxDecoration(
                        color: color.withOpacity(0.15),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        // Determine which ID to show
                        slot.status == 1 ? slot.id : slot.bookedBy,
                        // Use empty string if somehow both are empty
                        // (though bookedBy should be present for status 2)
                        // slot.id.isNotEmpty ? slot.id : slot.bookedBy,
                        style: TextStyle(
                            fontSize: 9, // Smaller font size for the ID/BookedBy
                            fontWeight: FontWeight.w500, // Slightly bolder
                        ),
                        overflow: TextOverflow.ellipsis, // Handle potential long IDs
                      ),
                    )
                  else
                  // Add a SizedBox to maintain alignment when text is absent
                    const SizedBox(height: 15), // Adjust height to roughly match text container
                ],
              );

              // Determine if the slot is tappable
              bool canBook = slot.status == 0 && !_hasExistingBooking();
              bool canCancel = slot.status == 2 && slot.bookedBy == _selectedId;

              // Return GestureDetector only if interaction is possible
              if (canBook || canCancel) {
                return GestureDetector(
                  onTap: () {
                    if (canBook) {
                      _confirmBooking(rowKey, index);
                    } else if (canCancel) {
                      _confirmCancellation(rowKey, index);
                    }
                  },
                  child: slotWidget,
                );
              } else {
                // Otherwise, just return the visual representation
                return slotWidget;
              }
            }),
          ),
        ],
      ),
    ),
  );

  @override
  Widget build(BuildContext context) => Scaffold(
    appBar: AppBar(
      title: const Text('Smart Parking Dashboard'),
      elevation: 0,
    ),
    body: Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [Colors.indigo.shade50, Colors.white],
        ),
      ),
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            /* device picker */
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    const Text('',
                        style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600)),
                    const SizedBox(width: 12),
                    DropdownButton<String>(
                      value: _selectedId,
                      items: _deviceIds
                          .map((id) => DropdownMenuItem(value: id, child: Text(id)))
                          .toList(),
                      onChanged: (v) => setState(() => _selectedId = v!),
                    ),
                    const Spacer(),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      decoration: BoxDecoration(
                        color: Colors.indigo.shade50,
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(color: Colors.indigo.shade200),
                      ),
                      child: Text(
                        '₹${_balanceForSelected().toStringAsFixed(2)}',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Colors.indigo.shade800,
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    ElevatedButton.icon(
                      onPressed: _addTen,
                      icon: const Icon(Icons.add),
                      label: const Text('₹10'),
                    ),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 16),

            /* overall wallet list */
            const Text('All wallets:',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            _buildBalancesList(),

            const SizedBox(height: 16),

            /* parking status indicator */
            if (_row1 != null && _row2 != null)
              Container(
                padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
                decoration: BoxDecoration(
                  color: _isFullyOccupied() ? Colors.red.shade100 : Colors.green.shade100,
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: _isFullyOccupied()
                          ? Colors.red.withOpacity(0.2)
                          : Colors.green.withOpacity(0.2),
                      blurRadius: 6,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Icon(
                      _isFullyOccupied() ? Icons.error_outline : Icons.check_circle_outline,
                      color: _isFullyOccupied() ? Colors.red.shade900 : Colors.green.shade900,
                      size: 24,
                    ),
                    const SizedBox(width: 12),
                    Text(
                      _isFullyOccupied() ? 'Parking is currently FULL' : 'Parking spots available',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: _isFullyOccupied() ? Colors.red.shade900 : Colors.green.shade900,
                      ),
                    ),
                  ],
                ),
              ),

            const SizedBox(height: 24),

            /* otp entry */
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Entry/Exit Access',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 12),
                    TextField(
                      controller: _otpController,
                      decoration: InputDecoration(
                        labelText: 'Enter 4-digit OTP',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        prefixIcon: const Icon(Icons.vpn_key),
                      ),
                      keyboardType: TextInputType.number,
                      maxLength: 4,
                    ),
                    const SizedBox(height: 10),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton.icon(
                        onPressed: _submitOtp,
                        icon: const Icon(Icons.send),
                        label: const Text('Submit OTP'),
                      ),
                    ),
                    if (_message != null)
                      Padding(
                        padding: const EdgeInsets.only(top: 12),
                        child: Text(
                          _message!,
                          style: TextStyle(
                            color: _message!.contains('Verified')
                                ? Colors.green.shade800
                                : Colors.red.shade800,
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 24),

            /* dashboard title */
            Row(
              children: [
                const Icon(Icons.sensors, size: 22),
                const SizedBox(width: 8),
                const Text(
                  'Sensor Data',
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.indigo.shade100,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: const Text(
                    'Tap to book or cancel',
                    style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),

            /* rows */
            _row1 != null
                ? _buildRow(_row1!, 'row1', 'Row 1')
                : const Center(child: CircularProgressIndicator()),

            _row2 != null
                ? _buildRow(_row2!, 'row2', 'Row 2')
                : const Center(child: CircularProgressIndicator()),

            const SizedBox(height: 12),

            // Legend for parking spots
            Card(
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildLegendItem(Colors.green.shade500, 'Available'),
                    _buildLegendItem(Colors.purple.shade500, 'Reserved'),
                    _buildLegendItem(Colors.red.shade500, 'Occupied'),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    ),
  );

  Widget _buildLegendItem(Color color, String label) {
    return Row(
      children: [
        Container(
          width: 16,
          height: 16,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
        ),
        const SizedBox(width: 6),
        Text(label, style: const TextStyle(fontSize: 12)),
      ],
    );
  }
}